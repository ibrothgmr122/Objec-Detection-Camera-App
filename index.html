<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RL Aimbot Detector</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- TensorFlow.js and COCO-SSD Model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        body {
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        .hud-text {
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
        }
        /* Scanning line animation */
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            animation: scan 3s linear infinite;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes scan {
            0% { top: -10%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 110%; opacity: 0; }
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 20;
        }
        video {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            object-fit: cover; /* Ensure full screen coverage */
            width: 100%;
            height: 100%;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            z-index: 30;
            pointer-events: none;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 0, 0.8);
        }
        .crosshair::before {
            top: 19px;
            left: 0;
            width: 40px;
            height: 2px;
        }
        .crosshair::after {
            top: 0;
            left: 19px;
            width: 2px;
            height: 40px;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid rgba(0, 255, 0, 0.1);
            border-left-color: #00ff00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="h-screen w-screen text-green-500 relative">

    <!-- Camera View -->
    <video id="webcam" playsinline muted autoplay></video>

    <!-- Drawing Layer -->
    <canvas id="canvas"></canvas>

    <!-- HUD / UI Overlay -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none z-30 flex flex-col justify-between p-4">
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div class="bg-black/50 p-2 border border-green-500/50 rounded backdrop-blur-sm">
                <h1 class="text-xs font-bold tracking-widest hud-text">SYSTEM: ONLINE</h1>
                <div class="text-[10px] opacity-70 mt-1">MODE: OBJECT_RECOGNITION</div>
                <div class="text-[10px] opacity-70">V.2.0.4</div>
            </div>
            <div class="text-right">
                <div id="fps-counter" class="text-xs font-bold hud-text">FPS: --</div>
                <div id="object-count" class="text-[10px] opacity-70">TARGETS: 0</div>
            </div>
        </div>

        <!-- Footer -->
        <div class="flex justify-between items-end">
            <div class="text-[10px] opacity-60 max-w-[50%]">
                CAM_FEED_01 <br>
                AUTO-TRACKING ENABLED
            </div>
            <button id="switch-cam" class="pointer-events-auto bg-green-900/80 text-green-100 border border-green-500 px-3 py-1 rounded text-xs font-bold uppercase active:scale-95 transition-transform">
                Flip Camera
            </button>
        </div>
    </div>

    <!-- Decorative Elements -->
    <div class="scan-line"></div>
    <div class="crosshair"></div>

    <!-- Loading Screen -->
    <div id="loading-screen" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center transition-opacity duration-500">
        <div class="loader mb-4"></div>
        <div class="text-green-500 font-mono text-sm tracking-widest animate-pulse">INITIALIZING NEURAL LINK...</div>
        <div id="loading-status" class="text-green-700 text-xs mt-2 font-mono">Loading Model...</div>
    </div>

    <!-- Error Message -->
    <div id="error-msg" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-900/90 border border-red-500 p-4 rounded text-white z-50 text-center max-w-xs">
        <div class="font-bold mb-2">ERROR</div>
        <p class="text-sm" id="error-text">Camera access denied.</p>
        <button onclick="location.reload()" class="mt-3 px-4 py-1 bg-red-700 rounded text-xs">RETRY</button>
    </div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingStatus = document.getElementById('loading-status');
        const errorMsg = document.getElementById('error-msg');
        const errorText = document.getElementById('error-text');
        const fpsCounter = document.getElementById('fps-counter');
        const objectCounter = document.getElementById('object-count');
        const switchCamBtn = document.getElementById('switch-cam');

        let model = undefined;
        let isDetecting = false;
        let lastTime = 0;
        let currentStream = null;
        let facingMode = 'environment'; // Start with back camera

        // Setup Canvas Size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Main Initialization
        async function init() {
            try {
                loadingStatus.innerText = "Loading COCO-SSD Model...";
                model = await cocoSsd.load();
                loadingStatus.innerText = "Accessing Camera...";
                await setupCamera();
                
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                }, 500);

                detectFrame();
            } catch (err) {
                console.error(err);
                showError("Could not initialize system. " + err.message);
            }
        }

        async function setupCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                audio: false,
                video: {
                    facingMode: facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play(); // Important for iOS/Android
                        resolve(video);
                    };
                });
            } catch (err) {
                showError("Camera permission denied or not available.");
                throw err;
            }
        }

        function showError(msg) {
            loadingScreen.classList.add('hidden');
            errorMsg.classList.remove('hidden');
            errorText.innerText = msg;
        }

        // Detection Loop
        async function detectFrame(time) {
            if (!model) return;

            // Calculate FPS
            if (time && lastTime) {
                const fps = Math.round(1000 / (time - lastTime));
                fpsCounter.innerText = `FPS: ${fps}`;
            }
            lastTime = time;

            // Detect objects
            // We might need to scale coords if video element and canvas size differ
            // video.videoWidth vs video.clientWidth
            
            let predictions = [];
            try {
                // Check if video is ready
                if (video.readyState === 4) {
                     predictions = await model.detect(video);
                }
            } catch (e) {
                console.warn("Detection error", e);
            }

            drawPredictions(predictions);
            
            requestAnimationFrame(detectFrame);
        }

        function drawPredictions(predictions) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            objectCounter.innerText = `TARGETS: ${predictions.length}`;

            // Calculate scaling factors
            // The video element is object-fit: cover, so we need to calculate the actual rendered dimensions
            const vidW = video.videoWidth;
            const vidH = video.videoHeight;
            const screenW = canvas.width;
            const screenH = canvas.height;
            
            if (vidW === 0 || vidH === 0) return;

            const vidRatio = vidW / vidH;
            const screenRatio = screenW / screenH;
            
            let scale, offsetX, offsetY;

            if (screenRatio > vidRatio) {
                // Screen is wider than video (crop top/bottom)
                scale = screenW / vidW;
                offsetX = 0;
                offsetY = (screenH - (vidH * scale)) / 2;
            } else {
                // Screen is taller than video (crop left/right) or equal
                scale = screenH / vidH;
                offsetX = (screenW - (vidW * scale)) / 2;
                offsetY = 0;
            }

            predictions.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                
                // Transform coordinates to match the displayed video
                const drawX = (x * scale) + offsetX;
                const drawY = (y * scale) + offsetY;
                const drawW = width * scale;
                const drawH = height * scale;

                // 1. Draw Box
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 2;
                
                // Draw corners only (Tech look)
                const cornerLen = Math.min(drawW, drawH) * 0.2;
                
                ctx.beginPath();
                // Top Left
                ctx.moveTo(drawX, drawY + cornerLen);
                ctx.lineTo(drawX, drawY);
                ctx.lineTo(drawX + cornerLen, drawY);
                
                // Top Right
                ctx.moveTo(drawX + drawW - cornerLen, drawY);
                ctx.lineTo(drawX + drawW, drawY);
                ctx.lineTo(drawX + drawW, drawY + cornerLen);
                
                // Bottom Right
                ctx.moveTo(drawX + drawW, drawY + drawH - cornerLen);
                ctx.lineTo(drawX + drawW, drawY + drawH);
                ctx.lineTo(drawX + drawW - cornerLen, drawY + drawH);
                
                // Bottom Left
                ctx.moveTo(drawX + cornerLen, drawY + drawH);
                ctx.lineTo(drawX, drawY + drawH);
                ctx.lineTo(drawX, drawY + drawH - cornerLen);
                
                ctx.stroke();

                // 2. Fill slightly
                ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                ctx.fillRect(drawX, drawY, drawW, drawH);

                // 3. Draw Label Background
                const text = `${prediction.class.toUpperCase()} ${(prediction.score * 100).toFixed(0)}%`;
                ctx.font = '12px "Courier New"';
                const textWidth = ctx.measureText(text).width;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(drawX, drawY - 20, textWidth + 10, 20);
                
                // 4. Draw Label Text
                ctx.fillStyle = '#00FF00';
                ctx.fillText(text, drawX + 5, drawY - 6);
                
                // 5. Line to center (Target lock feel)
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.moveTo(screenW / 2, screenH / 2);
                ctx.lineTo(drawX + drawW/2, drawY + drawH/2);
                ctx.stroke();
            });
        }

        // Camera Switch Logic
        switchCamBtn.addEventListener('click', async () => {
            facingMode = facingMode === 'user' ? 'environment' : 'user';
            loadingScreen.classList.remove('hidden');
            loadingScreen.style.opacity = '1';
            loadingStatus.innerText = "Switching Camera...";
            
            try {
                await setupCamera();
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                }, 500);
            } catch (e) {
                console.error(e);
                loadingScreen.classList.add('hidden');
            }
        });

        // Start
        window.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
